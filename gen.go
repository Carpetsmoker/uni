// +build go_run_only

package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"path"
	"sort"
	"strconv"
	"strings"
	"time"
)

func main() {
	var err error
	if len(os.Args) > 1 {
		err = run(os.Args[1])
	} else {
		err = run("unidata")
		if err == nil {
			err = run("entities")
			if err == nil {
				err = run("emojidata")
			}
		}
	}
	if err != nil {
		panic(err)
	}
}

func run(which string) error {
	var err error
	switch which {
	case "unidata":
		err = mkunidata()
	case "entities":
		err = mkentities()
	case "emojidata":
		err = mkemojidata()
	default:
		err = fmt.Errorf("unknown file: %q\n", which)
	}

	return err
}

func mkemojidata() (closeErr error) {
	fp, err := os.Create("gen_emoji.go")
	if err != nil {
		return err
	}
	defer func() { closeErr = fp.Close() }()

	_, err = fp.WriteString("// Code generated by gen.go; DO NOT EDIT\n" +
		"// nolint\n\n" +
		"package main\n\n" +
		"var emojidata = []emojiChar{\n")
	if err != nil {
		return err
	}

	seen := map[int64]struct{}{}
	urls := []string{"https://unicode.org/Public/emoji/12.0/emoji-data.txt",
		"https://unicode.org/Public/emoji/12.0/emoji-sequences.txt",
		"https://unicode.org/Public/emoji/12.0/emoji-zwj-sequences.txt"}
	for _, u := range urls {
		text, err := fetch(u)
		if err != nil {
			return err
		}

		for _, line := range bytes.Split(text, []byte("\n")) {
			if len(line) == 0 || line[0] == '#' {
				continue
			}

			codepoints := bytes.TrimSpace(bytes.Split(line, []byte(";"))[0])
			if bytes.Contains(codepoints, []byte(" ")) {
				// Multiple codepoints
				name := bytes.Split(line, []byte(";"))[2]
				name = name[:bytes.Index(name, []byte("#"))]
				name = bytes.TrimSpace(name)

				var cp []string
				for _, c := range bytes.Split(codepoints, []byte(" ")) {
					d, err := strconv.ParseInt(string(c), 16, 64)
					if err != nil {
						return err
					}
					if d != 0x200d {
						cp = append(cp, fmt.Sprintf("0x%x", d))
					}
				}

				_, err = fp.WriteString(fmt.Sprintf("\t{[]uint32{%s}, `%s`},\n",
					strings.Join(cp, ", "), name))
				if err != nil {
					return err
				}
			} else {
				// 2042 or 2042..2050
				s := strings.Split(string(codepoints), "..")
				switch len(s) {
				case 1:
					s = append(s, s[0])
				case 2:
					// Do nothing
				default:
					return fmt.Errorf("unknown:  %q", s)
				}

				start, err := strconv.ParseInt(s[0], 16, 64)
				if err != nil {
					return err
				}
				end, err := strconv.ParseInt(s[1], 16, 64)
				if err != nil {
					return err
				}

				for i := start; i <= end; i++ {
					if i < 0x2000 {
						continue // Exclude numbers etc.
					}

					if _, ok := seen[i]; ok {
						continue
					}
					seen[i] = struct{}{}

					// TODO: would be better to not rely on unidata as that's also
					// generated.
					x := fmt.Sprintf("%.4X", i)
					info, ok := unidata[x]
					if !ok {
						continue
					}

					_, err = fp.WriteString(fmt.Sprintf("\t{[]uint32{0x%x}, `%s`},\n",
						i, info.name))
					if err != nil {
						return err
					}
				}
			}
		}
	}

	_, err = fp.WriteString("}\n")
	if err != nil {
		return err
	}
	return closeErr
}

// http://www.unicode.org/reports/tr44/
func mkunidata() (closeErr error) {
	text, err := fetch("https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt")
	if err != nil {
		return err
	}

	widths, err := loadwidths()
	if err != nil {
		return err
	}

	fp, err := os.Create("gen_unidata.go")
	if err != nil {
		return err
	}
	defer func() { closeErr = fp.Close() }()

	_, err = fp.WriteString("// Code generated by gen.go; DO NOT EDIT\n" +
		"// nolint\n\n" +
		"package main\n\n" +
		"var unidata = map[string]char{\n")
	if err != nil {
		return err
	}

	for _, line := range bytes.Split(text, []byte("\n")) {
		if p := bytes.Index(line, []byte("#")); p > -1 {
			line = bytes.TrimSpace(line[p:])
		}
		if len(line) == 0 {
			continue
		}

		s := bytes.Split(line, []byte(";"))
		// Some properties (most notably control characters) all have the name
		// as <control>, which isn't very useful. The old (obsolete) Unicode 1
		// name field has a more useful name.
		// TODO: add this information from:
		// https://www.unicode.org/Public/UCD/latest/ucd/NamesList.txt
		name := s[1]
		if name[0] == '<' && len(s[10]) > 1 {
			name = s[10]
		}

		cp, err := strconv.ParseUint(string(s[0]), 16, 32)
		if err != nil {
			return err
		}

		_, err = fp.WriteString(fmt.Sprintf("\t\"%s\": {%d, %d, 0x%x, \"%s\"},\n",
			s[0], widths[cp], catmap[string(s[2])], cp, name))
		if err != nil {
			return err
		}
	}

	_, err = fp.WriteString("}\n")
	if err != nil {
		return err
	}

	return closeErr
}

func loadwidths() (map[uint64]uint8, error) {
	text, err := fetch("http://www.unicode.org/Public/UCD/latest/ucd/EastAsianWidth.txt")
	if err != nil {
		return nil, err
	}

	widths := make(map[uint64]uint8)
	for _, line := range bytes.Split(text, []byte("\n")) {
		if p := bytes.Index(line, []byte("#")); p > -1 {
			line = bytes.TrimSpace(line[:p])
		}
		if len(line) == 0 {
			continue
		}

		s := bytes.Split(line, []byte(";"))
		width := getwidth(string(s[1]))

		// Single codepoint.
		if !bytes.Contains(s[0], []byte("..")) {
			cp, err := strconv.ParseUint(string(s[0]), 16, 32)
			if err != nil {
				return nil, err
			}
			widths[cp] = width
			continue
		}

		rng := bytes.Split(s[0], []byte(".."))
		start, err := strconv.ParseUint(string(rng[0]), 16, 32)
		if err != nil {
			return nil, err
		}
		end, err := strconv.ParseUint(string(rng[1]), 16, 32)
		if err != nil {
			return nil, err
		}

		for cp := start; end >= cp; cp++ {
			widths[cp] = width
		}
	}

	return widths, nil
}

func getwidth(w string) uint8 {
	switch w {
	case "A":
		return widthAmbiguous
	case "F":
		return widthFullWidth
	case "H":
		return widthHalfWidth
	case "N":
		return widthNarrow
	case "Na":
		return widthNeutral
	case "W":
		return widthWide
	default:
		panic("wtf") // Never happens
	}
}

func mkentities() (closeErr error) {
	j, err := fetch("https://html.spec.whatwg.org/entities.json")
	if err != nil {
		return err
	}

	var out map[string]struct {
		Codepoints []uint32 `json:"codepoints"`
	}
	err = json.Unmarshal(j, &out)
	if err != nil {
		return err
	}

	fp, err := os.Create("gen_entities.go")
	if err != nil {
		return err
	}
	defer func() { closeErr = fp.Close() }()

	_, err = fp.WriteString("// Code generated by gen.go; DO NOT EDIT\n" +
		"// nolint\n\n" +
		"package main\n\n" +
		"var entities = map[rune]string{\n")
	if err != nil {
		return err
	}

	sorted := []string{}
	for k, _ := range out {
		// Backwards-compatible versions without closing ;
		if !strings.HasSuffix(k, ";") {
			continue
		}

		sorted = append(sorted, k)
	}

	// We want the shortest (&nbsp; instead of &NonBreakingSpace;).
	sort.Slice(sorted, func(i, j int) bool {
		return len(sorted[i]) < len(sorted[j])
	})

	var seen []uint32
	for _, ent := range sorted {
		cp := out[ent].Codepoints

		// TODO: some entities represent two codepoints; for example
		// &NotEqualTilde; is U+02242 (MINUS TILDE) plus U+000338 (COMBINING
		// LONG SOLIDUS OVERLAY).
		// I can't be bothered to implement this right now.
		if len(cp) != 1 {
			continue
		}

		found := false
		for _, s := range seen {
			if cp[0] == s {
				found = true
				break
			}
		}
		if found {
			continue
		}

		_, err = fp.WriteString(fmt.Sprintf("\t%d: \"%s\",\n",
			cp[0], strings.Trim(ent, "&;")))
		if err != nil {
			return err
		}

		seen = append(seen, cp[0])
	}

	_, err = fp.WriteString("}\n")
	if err != nil {
		return err
	}

	return closeErr
}

// Load .cache/file if it exists, or fetch from URL and store in .cache if it
// doesn't.
func fetch(url string) ([]byte, error) {
	file := "./.cache/" + path.Base(url)
	if _, err := os.Stat(file); err == nil {
		return ioutil.ReadFile(file)
	}

	client := http.Client{Timeout: 60 * time.Second}
	resp, err := client.Get(url)
	if err != nil {
		return nil, fmt.Errorf("cannot download %q: %s", url, err)
	}
	defer resp.Body.Close() // nolint: errcheck

	data, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("cannot read body of %q: %s", url, err)
	}

	if resp.StatusCode != http.StatusOK {
		return data, fmt.Errorf("unexpected status code %d %s for %q",
			resp.StatusCode, resp.Status, url)
	}

	err = ioutil.WriteFile(file, data, 0666)
	if err != nil {
		return nil, fmt.Errorf("could not write cache: %s", err)
	}

	return data, nil
}
